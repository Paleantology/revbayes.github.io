################################################################################
# Files.

time_tree_file="data/time.tree"
calibration_file="scripts/calibrations.rev"
constraints_file="scripts/constraints.rev"
mean_tree_file="output/alignment.fasta.trees_meanBL.nex"
var_tree_file="output/alignment.fasta.trees_varBL.nex"
out_bn="alignments.fasta.dating"

################################################################################
# Options.

constrain = true
mcmc_length = 50000
mcmc_burnin = 10000

moves = VectorMoves()
monitors = VectorMonitors()

################################################################################
# Get the original time tree.

# Tree.
tree <- readTrees(time_tree_file)[1]
print ("Root age : " + tree.rootAge())

# Number of branches.
n_species <- tree.ntips()
n_branches <- 2*n_species - 2

# Taxa.
taxa <- tree.taxa()

################################################################################
# Root prior.

age_fossil_root <- tree.rootAge()
width_age_prior_root <- age_fossil_root / 5
root_age_min <- age_fossil_root - width_age_prior_root
root_age_max <- age_fossil_root + width_age_prior_root
root_time_real ~ dnUniform(root_age_min, root_age_max)
root_time := abs( root_time_real )
root_time_real.setValue(tree.rootAge())

################################################################################
# Constraints.

if (constrain) {
  out_bn = out_bn + "_cons"
  constraints <- readRelativeNodeAgeConstraints(file=constraints_file);
}
################################################################################
# Tree model.

diversification ~ dnExp(1)
turnover ~ dnExp(1)
birth_rate := diversification + turnover
death_rate := turnover
moves.append(mvScale(diversification,lambda=1.0,tune=true,weight=3.0))
moves.append(mvScale(turnover,lambda=1.0,tune=true,weight=3.0))

if (!constrain) psi ~ dnBDP(lambda=birth_rate, mu=death_rate, rho=1.0, rootAge=root_time, samplingStrategy="uniform", condition="survival", taxa=taxa)
if (constrain) psi ~  dnConstrainedNodeOrder(dnBDP(lambda=birth_rate, mu=death_rate, rho=1.0, rootAge=root_time, samplingStrategy="uniform", condition="survival", taxa=taxa),constraints)

# Move ages of nodes.
moves.append(mvScale(root_time_real, weight=1.0, lambda=0.1))
moves.append(mvSubtreeScale(psi, weight=1.0*n_branches))
moves.append(mvNodeTimeSlideUniform(psi, weight=1.0*n_branches))
moves.append(mvLayeredScaleProposal(tree=psi, lambda=0.1, tune=true, weight=1.0*n_branches))

# The tree is fixed.
psi.setValue(tree)
print(psi)

################################################################################
# Obtain means and variances of branch lengths from first step.

mean_tree <- readTrees(mean_tree_file)[1]
var_tree <- readTrees(var_tree_file)[1]

mean_tree_root_age=mean_tree.rootAge()

for(i in 1:n_branches) {
  mean_bl[i] <- mean_tree.branchLength(i)
  var_bl[i] := var_tree.branchLength(i)
}

for(i in 1:n_branches) {
  if (mean_bl[i]<1e-10) mean_bl[i]:=1e-10
  if (var_bl[i]<1e-10) var_bl[i]:=1e-10
}

################################################################################
# Calibrations.

source(calibration_file)

################################################################################
# Molecular clock UGAM model.

global_rate_mean ~ dnExp(1)
global_rate_mean.setValue(mean_tree_root_age/tree.rootAge());
print("global_rate_mean: " + global_rate_mean)
sigma ~ dnExp(10.0)

first_gamma_param := 1/sigma
second_gamma_param := 1/sigma

moves.append(mvScaleBactrian(global_rate_mean, lambda=0.5, weight=10.0))
moves.append(mvScaleBactrian(sigma, lambda=0.5, weight=10.0))

# Use a Gamma distribution on rates.
for (j in n_branches:1)
{
  times[j]=psi.branchLength(j)
  rel_branch_rates[j] ~ dnGamma(first_gamma_param,second_gamma_param)
  rel_branch_rates[j].setValue(mean_bl[j]/times[j]/global_rate_mean)
  moves.append(mvScale(rel_branch_rates[j], lambda=0.5, weight=1.0,tune=true))
}

for (j in n_branches:1)
{
 branch_rates[j] := global_rate_mean * rel_branch_rates[j]
}

mean_rt := mean(branch_rates)
var_rt := var(branch_rates)
print(psi)

################################################################################
# CTMC.

if (type(branch_rates) == "RealPos") {
  for(i in 1:n_branches) {
    times[i] := psi.branchLength(i)
    mean_bl[i] := times[i]*branch_rates
    bls[i] ~ dnNormal(mean_bl[i] ,sqrt(var_bl[i]))
    bls[i].clamp(mean_bl[i])
  }
  bls[i] ~ dnNormal(mean_bl[i], sqrt(var_bl[i]))
  bls[i].clamp(mean_bl[i])
} else {
  for(i in 1:n_branches) {
    times[i] := psi.branchLength(i)
    mean_bl[i] := times[i]*branch_rates[i]
    bls[i] ~ dnNormal(mean_bl[i] ,sqrt(var_bl[i]))
    bls[i].clamp(mean_bl[i])
    }
  bls[i] ~ dnNormal(mean_bl[i] ,sqrt(var_bl[i]))
  bls[i].clamp(mean_bl[i])
}

################################################################################
# Log and monitors.

for(i in 1:n_branches)
{
  ages_psi[i] := psi.nodeAge(i)
  ages_true[i] := tree.nodeAge(i)
}
print(ages_psi)
print(ages_true)

monitors.append(mnModel(filename="output/"+out_bn+".log",printgen=10, separator = TAB))
monitors.append(mnStochasticVariable(filename="output/"+out_bn+"_Stoch.log",printgen=10))
monitors.append(mnExtNewick(filename="output/"+out_bn+".trees", isNodeParameter=FALSE, printgen=10, separator = TAB, tree=psi, branch_rates))
monitors.append(mnScreen(printgen=100, root_time, ages_psi[10], ages_psi[15], ages_psi[20]))

################################################################################
# MC3 Model.

mymodel = model(branch_rates)
mymcmc = mcmcmc(mymodel, monitors, moves, nruns=1, nchains=4, tuneHeat=TRUE)
mymcmc.burnin(generations=mcmc_burnin,tuningInterval=mcmc_burnin/10)
mymcmc.operatorSummary()
mymcmc.run(generations=mcmc_length)
mymcmc.operatorSummary()

q()
