################################################################################
# Files.

alignment_file="data/alignment.fasta"
constraints_file="data/constraints.txt"
time_tree_file="data/time.tree"
out_bn="alignment.fasta.exact.dating"

################################################################################
# Options.

# Show some debug output.
debug = true
# Use relative constraints.
constrain = true
# Length of Markov chain.
mcmc_length = 50000
mcmc_burnin = 100

################################################################################
# Variables used later.
moves = VectorMoves()
monitors = VectorMonitors()

data = readDiscreteCharacterData(alignment_file)
tree <- readTrees(time_tree_file)[1]
taxa <- tree.taxa()
n_species <- tree.ntips()
n_branches <- 2*n_species - 2

################################################################################
# Prior on root age.

# This is similar to the node calibration below. However, a prior on the root is
# always needed, and handled separaately.

root_age <- tree.rootAge()
root_age_delta <- root_age / 5
root_age_min <- root_age - root_age_delta
root_age_max <- root_age + root_age_delta
root_time_real ~ dnUniform(root_age_min, root_age_max)
root_time_real.setValue(tree.rootAge())
root_time := abs(root_time_real)

################################################################################
# Time tree model.

# Read the constraints. The constraints are added to the likelihood when
# instantiating the time tree psi.
if (constrain) {
  out_bn = out_bn + "_cons"
  constraints <- readRelativeNodeAgeConstraints(file=constraints_file);
}

birth_rate ~ dnExp(1)
moves.append(mvScale(birth_rate, lambda=1.0, tune=true, weight=3.0))

if (!constrain) psi ~ dnBDP(lambda=birth_rate, mu=0.0, rho=1.0, rootAge=root_time, samplingStrategy="uniform", condition="survival", taxa=taxa)
if (constrain) psi ~  dnConstrainedNodeOrder(dnBDP(lambda=birth_rate, mu=0.0, rho=1.0, rootAge=root_time, samplingStrategy="uniform", condition="survival", taxa=taxa), constraints)

psi.setValue(tree)
if (debug == true) {
  print("The original time tree:")
  print(tree)
  print("Root age of the original time tree: " + tree.rootAge())
  print("The tree used in the Markov chain:")
  print(psi)
}

moves.append(mvScale(root_time_real, weight=1.0, lambda=0.1))
moves.append(mvSubtreeScale(psi, weight=1.0*n_branches))
moves.append(mvNodeTimeSlideUniform(psi, weight=1.0*n_branches))
moves.append(mvLayeredScaleProposal(tree=psi, lambda=0.1, tune=true, weight=1.0*n_branches))

################################################################################
# Node calibrations provide information about the ages of the MRCA.

# The MRCAs of the following clades are calibrated.
clade_0 = clade("T_3","T_4","T_5")
clade_1 = clade("T_14","T_15","T_16","T_17")

# Clade 0.
tmrca_clade_0 := tmrca(psi, clade_0)
age_clade_0_mean <- tmrca(psi, clade_0)
age_clade_0_delta <- age_clade_0_mean / 5
age_clade_0_prior ~ dnSoftBoundUniformNormal(min=age_clade_0_mean-age_clade_0_delta, max=age_clade_0_mean+age_clade_0_delta, sd=2.5, p=0.95)
age_clade_0_prior.clamp(age_clade_0_mean)

# Clade 1.
tmrca_clade_1 := tmrca(psi, clade_1)
age_clade_1_mean <- tmrca(psi, clade_1)
age_clade_1_delta <- age_clade_1_mean / 5
age_clade_1_prior ~ dnSoftBoundUniformNormal(min=age_clade_1_mean-age_clade_1_delta, max=age_clade_1_mean+age_clade_1_delta, sd=2.5, p=0.95)
age_clade_1_prior.clamp(age_clade_1_mean)

################################################################################
# Molecular clock; uncorrelated gamma model.

global_rate_mean ~ dnExp(1)
global_rate_mean.setValue(1.0);
moves.append(mvScaleBactrian(global_rate_mean, lambda=0.5, weight=10.0))

sigma ~ dnExp(10.0)
first_gamma_param := 1/sigma
second_gamma_param := 1/sigma
moves.append(mvScaleBactrian(sigma, lambda=0.5, weight=10.0))

# Use a Gamma distribution on rates.
for (i in n_branches:1) {
  # TODO: To remove.
  # times[i]=psi.branchLength(i)
  rel_branch_rates[i] ~ dnGamma(first_gamma_param, second_gamma_param)
  rel_branch_rates[i].setValue(1.0)
  moves.append(mvScale(rel_branch_rates[i], lambda=0.5, weight=1.0, tune=true))
}

for (i in n_branches:1) {
  branch_rates[i] := global_rate_mean * rel_branch_rates[i]
}

################################################################################
# Substitution tree model. Inference of branch lengths using a Jukes-Cantor
# substitution model on a single alignment, with a fixed tree topology.

# Substitution Model.
Q <- fnJC(4)

seq ~ dnPhyloCTMC(tree=psi, Q=Q, branchRates=branch_rates, type="DNA")
seq.clamp(data)

if (debug == true) {
  print("Names of sequences in alignment:")
  print(data.names())
  print("Names of sequences in time tree:")
  print(psi.names())
}

################################################################################
# Monitors.

for(i in 1:n_branches)
{
  ages_psi[i] := psi.nodeAge(i)
  ages_true[i] := tree.nodeAge(i)
}
if (debug == true) print ("True node ages: " + ages_true)

monitors.append(mnModel(filename="output/"+out_bn+".log",printgen=10, separator = TAB))
monitors.append(mnStochasticVariable(filename="output/"+out_bn+"_Stoch.log",printgen=10))
monitors.append(mnExtNewick(filename="output/"+out_bn+".trees", isNodeParameter=false, printgen=10, separator = TAB, tree=psi, branch_rates))
monitors.append(mnScreen(printgen=100, root_time, ages_psi[20], ages_psi[25], ages_psi[27]))

################################################################################
# MC3 Model.

mymodel = model(psi)
mymcmc = mcmcmc(mymodel, monitors, moves, nruns=1, nchains=4, tuneHeat=TRUE)
mymcmc.burnin(generations=mcmc_burnin,tuningInterval=mcmc_burnin/10)
mymcmc.operatorSummary()
mymcmc.run(generations=mcmc_length)
mymcmc.operatorSummary()

q()
